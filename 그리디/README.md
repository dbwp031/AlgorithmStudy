# 그리디
### 풀이 흐름
어느 한 블로그에서 이상적인 풀이의 흐름과 현실적인 풀이의 흐름을 비교해 설명해주었습니다.
```
이상적인 풀이 흐름
1. 관찰을 통해 탐색 범위를 줄이는 방법을 고안한다.
2. 탐색 범위를 줄여도 올바른 결과를 낸다는 사실을 수학적으로 증명한다.
3. 구현해서 문제를 통과한다.
```
```
현실적인 풀이 흐름
1. 관찰을 통해 탐색 범위를 줄이는 방법을 고안한다.
2. 탐색 범위를 줄여도 올바른 결과를 낸다는 __강한 믿음__을 가진다.
3. 믿음을 가지고 구현해서 문제를 통과한다.
```
현실적으로 코딩 테스트에서 수학적으로 증명하기란 쉽지 않고, 그래서 관찰을 한 후, 그리디라 판단되면 강한 믿음을 가져야 한다고 합니다.  
그러니깐, 그리디 문제를 공부할 땐 **관찰을 통해 탐색 범위를 줄이는 방법을 고안하고 그리디로 가능하다고 믿는 과정**을 연습해야 하는데, 그리디인 걸 알고 들어가면 무지성 그리디 구현을 시작해버리게 됩니다.  
그러니깐, 문제를 보면 우선 관찰좀 하고 왜 그리디가 될까 정도는 고민하고 문제를 풀도록 합시다.

### 관찰
- [동전0](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_11047.py)
```
나에게 10원,50원,100원,500원이 있을 때, 가장 높은 동전부터 최대한 많이써야 최소한의 동전을 사용할 수 있을 것이다.
=> 사실은 하위의 동전들은 상위 동전을의 약수여야만 가능.
```
- [회의실 배정 [task scheduling problem]](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_1931.py)
```
처음엔 dp로 구현하려다 시간 최대값을 보고 메모리 초과로 판단해서 그리디로 선회했다.
끝나는 시간이 이른 회의부터 선택을 한다. 그러면 일찍 마치는 회의부터 선택할 수 있다.
=> 이때 같은 시간에 시작하고 끝나는 회의도 포함할 수 있게 잘 처리해주어야 한다.
=> time 막대를 그리고, 하나의 케이스에 대한 답들을 선택해놓은 다음, 시간을 1씩 늘려가며 각 
시간 때에 어떤 모습을 띄고 있는지 관찰하면 더 빠르게 아이디어를 떠올릴 수 있을 것 같다.
```
- [로프](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_2217.py)
```
로프들로 들을 수 있는 최대 무게 = (로프들 중 가장 약한 로프의 힘) * 로프 개수
따라서, 로프를 정렬해 준 후, 로프[i] * (len(로프들) - i) 로 max비교를 해주면 된다.
```
### 참고할 만한 사이트
[웃긴 그리디 설명 블로그](https://blog.encrypted.gg/975?category=773649)
