# 그리디
### 풀이 흐름
어느 한 블로그에서 이상적인 풀이의 흐름과 현실적인 풀이의 흐름을 비교해 설명해주었습니다.
```
이상적인 풀이 흐름
1. 관찰을 통해 탐색 범위를 줄이는 방법을 고안한다.
2. 탐색 범위를 줄여도 올바른 결과를 낸다는 사실을 수학적으로 증명한다.
3. 구현해서 문제를 통과한다.
```
```
현실적인 풀이 흐름
1. 관찰을 통해 탐색 범위를 줄이는 방법을 고안한다.
2. 탐색 범위를 줄여도 올바른 결과를 낸다는 __강한 믿음__을 가진다.
3. 믿음을 가지고 구현해서 문제를 통과한다.
```
현실적으로 코딩 테스트에서 수학적으로 증명하기란 쉽지 않고, 그래서 관찰을 한 후, 그리디라 판단되면 강한 믿음을 가져야 한다고 합니다.  
그러니깐, 그리디 문제를 공부할 땐 **관찰을 통해 탐색 범위를 줄이는 방법을 고안하고 그리디로 가능하다고 믿는 과정**을 연습해야 하는데, 그리디인 걸 알고 들어가면 무지성 그리디 구현을 시작해버리게 됩니다.  
그러니깐, 문제를 보면 우선 관찰좀 하고 왜 그리디가 될까 정도는 고민하고 문제를 풀도록 합시다.

# 관찰
## K개의 묶음, K-1개의 간선 선택
- [⭐센서](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_2212.py)
```
[센서 문제]는 골드 문제로, 이런 류의 문제를 몇 번 봤다. 우선 집중소 하나가 여러개의 노드를 감싸안아야 한다. 그 의미는 start 노드 ~ end 노드 거리가 집중소 값이다.  
그림을 그려서 잘 생각해보면 집중소들이 커버하는 거리의 합 = 전체 거리 - 커버하지 않는 거리
이고, 이 커버하지 않는 거리는 k-1개임을 알 수 있다. 그러면 "집중소 커버 거리 합"이 최소가 되기 위해선 커버하지 않는 거리가 최대가 되면 되고, 그렇다면 노드 사이의 거리들 중
가장 긴 k-1개의 거리의 합을 커버하지 않으면 된다는 것을 알 수 있다. 
```
<img src="https://user-images.githubusercontent.com/65337423/169980607-18b7f814-d816-405d-a5df-8453680fab86.png" height="200">

- [행복 유치원](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_13164.py)
```
센서와 같은 느낌의 문제이다. 핵심은 해당 노드의 값이 중요한게 아니라 노드와 노드간의 차이가 중요한 거고,
k개의 묶음을 만든다는 것은 k-1개의 간선을 선택해서 그 것들을 제외한다는의미이다.
=> 따라서 최소의 값이 되기 위해선 가장 긴 간선 순으로 제거하면 된다.
```

- [우체국](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_2141.py)
```
비슷한 유형인 그리디 문제였습니다. 한 줄의 노드 중에서 어떤 위치를 선택했을 때 문제에 대한 최적 값이냐를 풀어야하는 문제였습니다.
일단 이 문제는 어떻게 풀 수 있었나? 일단 머리 속으로는 매우 간단히 구현할 수 있는 문제였지만, 실제로 구현해보니 필요한 변수들이 몇가지가 더 있었습니다.
우선 left (현재 왼쪽의 값) 과 lp(왼쪽의 인원 수), right (현재 오른쪽 값) 과 rp(오른쪽 인원 수)로,
left += dist * lp
right -= dist * rp
그리고 복잡도상 O(N)까지 밖에 안되기 때문에 노드 한번씩 접근해서 값을 업데이트 해가면 됩니다.
=> 결국에 복잡도 한계로 노드를 한번씩 접근해야 된다고 판단하니깐, 어떤 순서로 접근해야 할지 고민하게 됐습니다. => 이때 그냥 순차적으로 접근하면서 값들을 업데이트 해나가면
됐습니다.
=> 어떤 방식으로 값이 업데이트가 되는 것인지 정확히 구현해내는 것이 가장 중요했습니다.
```

## 배정 문제 ( 아이디어는 비슷하지 않을 수 있음)
- [⭐회의실 배정 [task scheduling problem]](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_1931.py)
```
처음엔 dp로 구현하려다 시간 최대값을 보고 메모리 초과로 판단해서 그리디로 선회했다.
끝나는 시간이 이른 회의부터 선택을 한다. 그러면 일찍 마치는 회의부터 선택할 수 있다.
=> 이때 같은 시간에 시작하고 끝나는 회의도 포함할 수 있게 잘 처리해주어야 한다.
=> time 막대를 그리고, 하나의 케이스에 대한 답들을 선택해놓은 다음, 시간을 1씩 늘려가며 각 
시간 때에 어떤 모습을 띄고 있는지 관찰하면 더 빠르게 아이디어를 떠올릴 수 있을 것 같다.
```
- [⭐강의실 배정](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_11000.py)
```
이 문제는 결국에 답지를 보고 이해했다. 아이디어는 비슷했지만, 쉬운 그리디 문제들에 익숙해져있다 보니, 그리디는 매우 간단하게 구현 가능하고, 다른 자료구조는
사용하지 않아도 된다고 생각했었다. 그렇지만, 그리디는 "현재 상황에서 가장 좋은 것을 선택하는 방법론"일 뿐이고, 여러 자료구조가 사용될 수 있다.
그리고 이 문제에서는, "새 강의의 시작시간이 현재 강의가 끝나는 시간보다 빠르면 강의실을 하나 더 추가해야 한다."라는 아이디어였는데, 여기에서 우선순위 큐를 써서 현재 기준으로
가장 빨리 끝나는 강의와 계속 비교할 수 있도록 해줘야 한다. 그래서 이 우선순위 큐가 "강의실 수" 자체가 된다는 아이디어가 매우 인상 깊었다.
=> [참고한 사이트]:https://hongcoding.tistory.com/79
```
## 포인터 문제
- [배](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_1092.py)
```
이 문제는 아이디어는 쉽게 떠올릴 수 있지만, 구현이 생각보다 잘 안됐었다. 각 크레인마다 무게 한계가 있고, 박스가 한계보다 낮다면 옮기는 것을 구현하면 됐다.
이를 위해, 해당 박스를 옮겼는지 확인하기 위해서 visited를 사용했다.
그리고, 무게한계가 8이면 가능한 인덱스부터 마지막 인덱스까지 옮길 수 있도록 구현하기 위해 정렬을 하되, reverse=True로 구현했다.
=> 참고로 다른 아이디어도 있었다.
박스 크기대로 정렬한 후, 각 박스를 옮길 수 있는 크레인 수를 저장한다. 그 후에, 현재 박스 수와 크레인 사용 가능 수를 비교해서 박스 수가 더 크다면 하루를 추가하는 식으로
구현을 했는데, 이렇게 하면 각 크레인이 크기가 다른 (박스에서 바로 옆에 붙어있지 않은) 박스들은 동시에 옮기는 상황이 구현이 안되기 때문에 이런식으로 구현하면 안된다.
=> 이 방법은 책에있는 그리디 문제에 적합하다.
```

- [동전0](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_11047.py)
```
나에게 10원,50원,100원,500원이 있을 때, 가장 높은 동전부터 최대한 많이써야 최소한의 동전을 사용할 수 있을 것이다.
=> 사실은 하위의 동전들은 상위 동전을의 약수여야만 가능.
```

- [로프](https://github.com/dbwp031/YujeCodingTest/blob/main/%EA%B7%B8%EB%A6%AC%EB%94%94/baek_2217.py)
```
로프들로 들을 수 있는 최대 무게 = (로프들 중 가장 약한 로프의 힘) * 로프 개수
따라서, 로프를 정렬해 준 후, 로프[i] * (len(로프들) - i) 로 max비교를 해주면 된다.
```
### 참고할 만한 사이트
[웃긴 그리디 설명 블로그](https://blog.encrypted.gg/975?category=773649)
[그리디 문제집](https://www.acmicpc.net/workbook/view/4380)
