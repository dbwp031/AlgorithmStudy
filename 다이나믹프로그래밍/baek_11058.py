# 이전 기타 문제처럼 2차원 dp 테이블을 사용하면 될 것 같습니다.
# i는 누르는 번수, j=0,1,2,3으로 각각 4가지의 행동 중 하나를 했을 때의 최대값을 저장하면 될 것 같네요.
# 라고 생각했는데 아닌것 같네요

# 일단 dp문제는 풀기 전에 제가 생각하는 dp테이블의 복잡도 / 메모리 상한을 고려하긴 해야 할 듯 싶습니다.
N = int(input())
dp = [[0]*2 for _ in range(N+1)]

# 만약 현재 버퍼와 -3 버퍼의 비교가 같다면 새 버퍼의 크기가 더 좋으니까 -3을 우선시해야함.

# for n in range(1,N+1):
    
#     if n>=3 and dp[n-2][0]*2 >= dp[n-1][0]+dp[n-1][1] and  dp[n-2][0]*2 >=dp[n-1][0]+1:
#         dp[n][0]=dp[n-2][0]*2
#         dp[n][1]=dp[n-2][0]
#     elif n>=3 and dp[n-1][0]+dp[n-1][1] >=dp[n-1][0]+1:
#         dp[n][0]=dp[n-1][0]+dp[n-1][1]
#         dp[n][1]=dp[n-1][1]
#     else:
        
#         dp[n][0]=dp[n-1][0]+1
#         dp[n][1]=dp[n-1][1]
        
# for d in dp:
#     print(*d)
# print(dp[-1][0])

# 선택-복-붙 vs 붙 만 고려했습니다.
# 그런데 선복붙 vs붙붙붙붙 vs 붙붙붙붙붙 을 비교해야 했습니다.
# 왜냐하면 6이후부터는 붙이 반드시 이득이고,
# 음.. 그런데 약간 그리디 느낌이 납니다.
# 이렇게 그리디한 문제들은 확실히 증명을하고 구현을 해야할지, 그냥 느낌적으로 풀어야 할지 잘 모르겠네요..

n = int(input())
dp = [i for i in range(101)]
for i in range(6,101):
    dp[i]=max(dp[i-3]*2,dp[i-4]*3,dp[i-5]*4)
print(dp[n])