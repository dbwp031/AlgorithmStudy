# 이 문제는 다른 dp문제들이랑 약간 결이 다른 느낌이다.
# 다른 문제들은 계속 최대를 구하거나, 계속 최소를 구하는 느낌이었다.
# 그런데 이 느낌은 덧셈 혹은 뺄셈을 선택하는 과정이고, 현재 기준의 최대, 혹은 최소를 구하는게 결정되지가 않았습니다.

# 근데 이거 걍 다이나믹 말고 브루트포스로 풀어도 될꺼깥은데? => 메모리초과로 실패했습니다. 

# 아래는 해당 코드

# n,s,m=map(int,input().split())
# data = list(map(int,input().split()))
# dp = [[s]]

# for i in range(n):
#     temp = []
#     for j in dp[-1]:
#         if j-data[i] >=0:
#             temp.append(j-data[i])
#         if j+data[i]<=m:
#             temp.append(j+data[i])
#     dp.append(temp)
# if len(dp[-1])==0:
#     print(-1)
# else:
#     print(max(dp[-1]))


# dp를 설정해서 해주었더니 풀렸다. 일단 웃긴게 위의 아이디어랑 크게 다른건 없다. 그냥 위에서는 가능한 값이면 리스트에 넣어주고,
# dp로 푼 방법은 가능하면 1로 설정해주는 것이다.
# 다른 부분은 아래와 같다.
# 중복 검사를 하지 않았다보니(1번에서) 같은 값이 여러번 들어갈 수 있고, 이로인해 메모리 초과가 일어납니다.
# 그런데 dp를 사용하면 해당 값이 1이 되는게 끝이기 때문에 중복은 없습니다.
## dp테이블은 복잡도상 / 메모리상 가능할 때, 간편하게 중복을 방지할 수 있는 방법인 것 같습니다.

## 그리고 dp라는 것이 "이전의 정보를 활용한다"라는 아이디어인 것이지, "이전의 최대의 정보를 활용한다"라는 아이디어는 아닙니다.
# 물론 최대, 최소만 저장하면 되는 dp문제들이 많긴 하지만 이번 문제처럼 아닌 것도 존재합니다.

## 그리고 이렇게 2차원 dp 테이블의 dp[i][j] => i인덱스의서의 j상태를 의미하게 사용할 수 있습니다.
# 그니깐, dp[i]=> i인덱스의 상태 1가지만 저장할 수 있었다면(보통 최대 혹은 최소를 저장합니다)
# 이렇게 2차원으로 하면 dp[i]의 0 ~ j까지의 상태를 모두 표현할 수 있는 것이죠.


n,s,m=map(int,input().split())
data = list(map(int,input().split()))

dp = [[0]*(m+1) for _ in range(n+1)]
dp[0][s]=1
for i in range(0,n):
    for j in range(0,m+1):
        if dp[i][j] == 1:
            v = data[i]
            if j-v >=0: dp[i+1][j-v]=1
            if j+v<=m: dp[i+1][j+v]=1

midx=-1
for i in range(0,m+1):
    if dp[-1][i]==1:
        midx=i
print(midx)