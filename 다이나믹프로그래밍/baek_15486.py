# 일단 퇴사 1은 예전에 풀었던 기억을 토대로, 어떻게든 풀어냄.
# 퇴사 1을 풀때, dp 테이블을 직접 그려가며 이해했더니 빠르게 풀어낼 수 있었음.
# 하지만 이 문제는 N이 1.5*10^6승이라 복잡도가 O(N)보다 높으면 안됨. => O(NlogN)도 가능할수도?

# 퇴사1은 만약 max가 업데이트가 되면 그 뒤의 날들을 모두 비교해주게 된다.
# 따라서 최대 복잡도는 O(N^2)이다.


# 어 뭐지 왜 잘풀리지 dp 이해도 잘 안되는데
# 일단 이 주제는 내가 답지 본 경험이 있어서 그런 걸 수 있으니까 일단 좀 더 풀어보자.

# 그래도 일단 어떻게 풀었는지 적어보자면,
# 일단 이런 dp 문제는 해당 날짜를 방문하면, 그 날은 그날의 최대값이 확정이 된다.
# 첫번째 날에 대한 처리가 끝나고 나면, 첫번째 날의 최대는 다시 바뀌지 않는다.
# 즉 이런식으로 해당 날짜에 대한 최대만 보장해주면 N번째 날 후에는 N번째 날의 최대가 보장이 될 거다.
# 그래서 i번째 날짜에 방문 시작한다고 가정하자.
# 그러면 i-1째 날의 max값은 확정이 되어있습니다. 그래서 전 날의 최대값과 오늘날의 업데이트 값을 비교해서 오늘날의 최대를 업데이트 해줍니다.
# 그리고, 그 날 일에 대한 정보를 업데이트해줍니다. => 즉 현재시점에 대해서 모든 날의 최대 값은 보장이 안되는 겁니당.
# 미래에 대해서 최대가 보장이 되는건 퇴사1번 풀이입니다.

# 오 근데 이 아이디어는 좋은 것 같네요.
# i번째 방문에선 i-1번째까지의 dp만 보장되어 있고, 이를 활용해 i번째의 dp를 보장시켜주고, i+1~(미래)에 대해서는 그냥 값 업데이트만 해준다.

# 이런게 가능하다는 걸 알고, dp 테이블을 직접 그려가면서 풀어내는게 일단 가장 빠르게 풀어낼 수 있는듯 합니다.
# 1. 
import sys
input =sys.stdin.readline
n = int(input())
dp = [0]*(n+2)
for now_day in range(1,n+1):
    now_cost,now_money = map(int,input().split())
    dp[now_day] = max(dp[now_day],dp[now_day-1])
    if now_day+now_cost <=n+1:
        dp[now_day+now_cost]=max(dp[now_day+now_cost],dp[now_day]+now_money)
dp[n+1] = max(dp[n+1],dp[n])
print(dp[n+1])